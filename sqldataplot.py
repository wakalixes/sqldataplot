"""
*   This module is part of the sql_data_plot.py application
*   $Rev: 25 $
*   $Date: 2011-08-06 14:15:57 +0200 (Sat, 06 Aug 2011) $
*   $Author: stefan $
*
*   Copyright notice:
* 
*   (c) 2011 Stefan Besler (stefan.besler@gmail.com)
*       2012-2013 Bo Huang (bo.huang@uibk.ac.at)
*       2012-2013 Albert Frisch (albert.frisch@gmail.com)
*   All rights reserved
*
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

from __future__ import with_statement
import numpy as np
import csv as csv
import sys
import time
import re
import os
import math
from collections import defaultdict
from datetime import datetime

from scipy import linspace, polyval, polyfit, sqrt, stats, randn
#from uncertainties import ufloat, nominal_value, std_dev

from sdp_ui import Ui_MainWindow
from exportdialog import ExportDialogWindow
from authenticate import AuthenticateDialog

from PyQt4 import QtCore
from PyQt4 import QtGui
import PyQt4.Qwt5 as Qwt

from errorbar_curve import ErrorBarPlotCurve

from pysqlite2 import dbapi2 as sqlite
import MySQLdb as mysql

from plugins.pluginInterfaces import PluginFit, PluginTransform, find_subclasses
import plugins.pluginFitNone

debugMessages=False
debugTiming=False

def errorMessage(s):
  print s

def message(s):
  if debugMessages:
    print s
  else:
    pass
  
def round_to_n(x, n):
    if n < 1:
        raise ValueError("number of significant digits must be >= 1")
    # Use %e format to get the n most significant digits, as a string.
    format = "%." + str(n-1) + "e"
    as_string = format % x
    return float(as_string)
  
class Spy(QtCore.QObject):
    
    def __init__(self, parent):
        QtCore.QObject.__init__(self, parent)
        parent.setMouseTracking(True)
        parent.installEventFilter(self)

    def eventFilter(self, _, event):
        if event.type() == QtCore.QEvent.MouseMove:
            self.emit(QtCore.SIGNAL("MouseMove"), event.pos())
        return False

class SqlDataPlotMainWindow(QtGui.QMainWindow, Ui_MainWindow):
  """Customization for Qt Designer creapyth ted window"""
  time=time.time()
  currentData=np.array([])
  currentFitData=np.array([])
  currentErrData=np.array([])
  currentLast=np.array([])
  fitPlugins=''
  db=''
  fitSelectedPlugin=''
  transformSelectedPlugin=''
  numAxes=4
  dataset=''
  date=''
  numConditions=3
  comparisons = ["!=", "=", "<", ">"]
  fileWatch=''
  curves = []
  pickingMode = "zoom"
  preventLoadingData = False
  useoldAxes = 0
  queryexectime = 0
  
  def __init__(self, parent = None):
    # initialization of the superclass
    super(SqlDataPlotMainWindow, self).__init__()
    # setup the GUI --> function generated by pyuic4
    self.setupUi(self)
    self.pathname = os.path.realpath(os.path.dirname(sys.argv[0]))
    self.setEnabled(False)
    self.authenticateDialog = AuthenticateDialog(self)
    QtCore.QObject.connect(self.authenticateDialog, QtCore.SIGNAL('accepted()'),self.__initGUI)
    QtCore.QObject.connect(self.authenticateDialog, QtCore.SIGNAL('rejected()'),self.close)
    self.authenticateDialog.show()
  #__init__(self, parent = None)

  def __initGUI(self):
    QtCore.QObject.connect(self.fillAutoFitParametersButton, QtCore.SIGNAL('clicked()'),self.fillAutoParameters)
    QtCore.QObject.connect(self.applyAxisStyleButton, QtCore.SIGNAL('clicked()'),self.loadData)
    QtCore.QObject.connect(self.resetAxisStyleButton, QtCore.SIGNAL('clicked()'),self.resetAxisStyle)
    QtCore.QObject.connect(self.datasetList, QtCore.SIGNAL('itemClicked(QListWidgetItem*)'),self.datasetSelected)
    QtCore.QObject.connect(self.plotStyleListLinePlot, QtCore.SIGNAL('clicked()'),self.loadData)
    QtCore.QObject.connect(self.plotStyleListPlot, QtCore.SIGNAL('clicked()'),self.loadData)
    QtCore.QObject.connect(self.oldAxesButton, QtCore.SIGNAL('clicked()'),self.oldAxes)
    QtCore.QObject.connect(self.addAxesButton, QtCore.SIGNAL('clicked()'),self.addAxes)
    QtCore.QObject.connect(self.removeAxesButton, QtCore.SIGNAL('clicked()'),self.removeAxes)
    QtCore.QObject.connect(self.addConditionButton, QtCore.SIGNAL('clicked()'),self.addCondition)
    QtCore.QObject.connect(self.removeConditionButton, QtCore.SIGNAL('clicked()'),self.removeCondition)  
    QtCore.QObject.connect(self.clipboardPlotButton, QtCore.SIGNAL('clicked()'),self.copyPlotToClipboard)  
    QtCore.QObject.connect(self.clipboardDataButton, QtCore.SIGNAL('clicked()'),self.copyDataToClipboard)
    QtCore.QObject.connect(self.disableConditionsButton, QtCore.SIGNAL('clicked()'),self.toggleConditions)
    QtCore.QObject.connect(self.avgStdSqrtN, QtCore.SIGNAL('clicked()'),self.loadData)  
    QtCore.QObject.connect(self.avgStd, QtCore.SIGNAL('clicked()'),self.loadData)
    QtCore.QObject.connect(self.parametersTbl, QtCore.SIGNAL('cellChanged(int, int)'),self.loadData)
    QtCore.QObject.connect(self.transformConstantTbl, QtCore.SIGNAL('cellChanged(int, int)'),self.loadData)  
    QtCore.QObject.connect(self.axesTbl, QtCore.SIGNAL('cellChanged(int, int)'),self.loadData)
    QtCore.QObject.connect(self.pickingModeCombo, QtCore.SIGNAL('activated(const QString&)'),self.changePickingMode)
    QtCore.QObject.connect(self.exportDataButton, QtCore.SIGNAL('clicked()'),self.exportData)       
    QtCore.QObject.connect(self.updateFitRangeButton, QtCore.SIGNAL("clicked()"), self.loadData)
    QtCore.QObject.connect(self.updateRangeButton, QtCore.SIGNAL("clicked()"), self.loadData)
    QtCore.QObject.connect(self.resetRangeButton, QtCore.SIGNAL("clicked()"), self.resetRange)
    QtCore.QObject.connect(self.infoCopyEdit, QtCore.SIGNAL("clicked()"), self.copyInfo)

    #setup a file watcher
    self.fileWatch = QtCore.QFileSystemWatcher(self)
    self.fileWatch.addPath("../db/mysqldb.log")
    QtCore.QObject.connect(self.fileWatch, QtCore.SIGNAL('fileChanged(const QString&)'),self.databaseChanged) 

    # gui adjustment
    self.axesTbl.setRowCount(0)
    self.axesTbl.setColumnCount(5)
    self.axesTbl.setHorizontalHeaderLabels(["type", "scale", "offset", "fit",""])
    self.axesTbl.setRowHeight(0,20)
    
    self.conditionTbl.setRowCount(0)
    self.conditionTbl.setColumnCount(5)
    self.conditionTbl.setHorizontalHeaderLabels(["","name", "condition", "val",""])
    self.conditionTbl.setRowHeight(0,20)

    for i in xrange(self.axesTbl.rowCount()):
      self.axesTbl.resizeColumnToContents(i)

    for i in xrange(self.conditionTbl.rowCount()):
      self.conditionTbl.resizeColumnToContents(i)

    for i in xrange(self.parametersTbl.rowCount()):
      self.parametersTbl.resizeColumnToContents(i)
    
    #look for fitting plugins and add them
    self.fitPlugins = find_subclasses("plugins/", PluginFit)
    for i,plugin in enumerate(self.fitPlugins):
      self.fitTypeCombo.addItem(QtCore.QString(plugin().getFitModelStr()))        
      if plugin().getFitModelStr() == "None":
        self.fitSelectedPlugin=plugin()
        self.fitTypeCombo.setCurrentIndex(i)

    #look for transform plugins and add them
    self.transformPlugins = find_subclasses("plugins/", PluginTransform)
    for i,plugin in enumerate(self.transformPlugins):
      self.transformTypeCombo.addItem(QtCore.QString(plugin().getTransformModelStr()))        
      if plugin().getTransformModelStr() == "Identity":
        self.transformTypeCombo.setCurrentIndex(i)
        self.transformPluginSelected(i)

    #connect to database
    self.connectToDatabase()

    QtCore.QObject.connect(self.fitTypeCombo, QtCore.SIGNAL('activated(int)'),self.fitPluginSelected)
    QtCore.QObject.connect(self.transformTypeCombo, QtCore.SIGNAL('activated(int)'),self.transformPluginSelected)
    QtCore.QObject.connect(self.averageDataButton, QtCore.SIGNAL('clicked()'),self.loadData)
    QtCore.QObject.connect(self.transformDataButton, QtCore.SIGNAL('clicked()'),self.toggledTransform)
    QtCore.QObject.connect(self.fitDataButton, QtCore.SIGNAL('clicked()'),self.loadData)
    
    QtCore.QObject.connect(self.dateCombo, QtCore.SIGNAL('activated(const QString&)'),self.dateSelected)
    self.dateCombo.setCurrentIndex(0)
    self.dateSelected(self.dateCombo.currentText())
  
    #setup the plot for output
    self.__initPlot(self.mainPlot)
    self.__initTracking()
    self.__initZooming()
    self.__initPicking()
    self.__initPanning()

    self.changePickingMode("zoom")
    self.loadSettings()
    self.fillAutoParameters()
    self.toggledTransform(True)
    self.loadData()
    
    # timer to make a stupid mysql call in order to keep the connection alive
    self.timer=QtCore.QTimer()
    QtCore.QObject.connect(self.timer,QtCore.SIGNAL('timeout()'), self.dontLooseConnection)
    self.timer.start(1000*60*60)
  #__initGUI(self)

  def __initTracking(self):      
    self.connect(Spy(self.mainPlot.canvas()),QtCore.SIGNAL("MouseMove"),self.showCoordinates)
  #__initTracking(self)

  def __initZooming(self):
        self.zoomer = Qwt.QwtPlotZoomer(Qwt.QwtPlot.xBottom, \
                                        Qwt.QwtPlot.yLeft, \
                                        Qwt.QwtPicker.DragSelection, \
                                        Qwt.QwtPicker.AlwaysOff, \
                                        self.mainPlot.canvas())
        self.zoomer.setRubberBandPen(QtGui.QPen(QtCore.Qt.black))
        self.zoomer.initMousePattern(3)
  #__initZooming(self)

  def __initPicking(self):
    self.picker = Qwt.QwtPlotPicker(Qwt.QwtPlot.xBottom,\
                               Qwt.QwtPlot.yLeft,\
                               Qwt.QwtPicker.PointSelection,\
                               Qwt.QwtPlotPicker.CrossRubberBand,\
                               Qwt.QwtPicker.AlwaysOn,\
                               self.mainPlot.canvas())
    self.picker.setRubberBandPen(QtGui.QPen(QtCore.Qt.black))
    self.picker.setEnabled(False)
    self.picker.connect(self.picker, QtCore.SIGNAL('selected(const QwtDoublePoint&)'), self.pickedPoint)
  #__initPicking(self)

  def __initPanning(self):
    self.panner = Qwt.QwtPlotPanner(self.mainPlot.canvas())
    self.panner.setEnabled(False)
  #__initPanning(self)

  def __initPlot(self, plot):
    grid = Qwt.QwtPlotGrid()
    pen = QtGui.QPen(QtCore.Qt.DotLine)
    pen.setColor(QtCore.Qt.black)
    pen.setWidth(0)   
    grid.setPen(pen)
    grid.attach(plot)   
    plot.brushColor = QtCore.Qt.white
    plot.enableAxis(False)
    plot.setCanvasBackground(QtCore.Qt.white)
    plot.plotLayout().setCanvasMargin(0)
    plot.canvas().setFrameStyle(QtGui.QFrame.Plain)
    
    plot.enableAxis(0, True)
    plot.enableAxis(2, True)
    plot.enableAxis(1, False)
    plot.enableAxis(3, False)

    scaleDrawX = Qwt.QwtScaleDraw()
    scaleDrawX.setAlignment(Qwt.QwtScaleDraw.LeftScale )
    scaleDrawX.setLabelRotation(0)
    scaleDrawY = Qwt.QwtScaleDraw()
    scaleDrawY.setAlignment(Qwt.QwtScaleDraw.BottomScale )
    scaleDrawY.setLabelRotation(0)

    legend = Qwt.QwtLegend()
    legend.setItemMode(Qwt.QwtLegend.CheckableItem)
    plot.insertLegend(legend, Qwt.QwtPlot.RightLegend)
  #__initPlot(self, plot)

  def dontLooseConnection(self):
    try:        
      self.dbcur.execute("SELECT * FROM dataTable LIMIT 1")
      self.saveInfo()
      self.db.commit()
    except mysql.Error,e:
      print "Error in keeping connetion alive, reconnecting..."
      self.connectToDatabase()
  #dontLooseConnection(self)

  def toggleBackupFile(self):
    try:
      self.connectToDatabase()
    finally:
      pass
        
      self.connectToDatabase(False)
      self.dateSelected(self.dateCombo.currentText())
  #toggleBackupFile(self)

  def copyInfo(self):
    self.saveInfo()
    
    self.conditionCursor.execute("SELECT Date, Dataset, Conditions, Temperature, Holding, Trap, Ramping, Compressed, Calibration, Text " \
                       "FROM conditionTable WHERE Date=%s and Dataset=%s LIMIT 1", (self.date,self.dataset))
    dt = self.conditionCursor.fetchall()

    if len(dt) > 0:
      copyStr="%s:" \
        "\n\tTemperature:%s" \
        "\n\tHolding-Time:%s" \
        "\n\tTrap:%s" \
        "\n\tRamping: %s" \
        "\n\tCompressed: %s" \
        "\n\tCalibration Resonance:%s" \
        "\n\tConditions: %s" \
        "\n\t%s" % (str(dt[0][1]),str(dt[0][3]),str(dt[0][4]),str(dt[0][5]),str(dt[0][6]),str(dt[0][7]),str(dt[0][8]),str(dt[0][2]),str(dt[0][9]))

      cb = QtGui.QApplication.clipboard()
      cb.setText(copyStr)
      
    self.db.commit()
  #copyInfo(self)

  def saveInfo(self,i=0):
    global debugMessages
    if self.date == "" or self.dataset == "" or debugMessages:
      print "not saving infos!"
      return
    
    message ("Storing info")
    idstr = "%s::%s" % (self.date, self.dataset)
    condStr = ""
    for i in xrange(self.conditionTbl.rowCount()):
      checked = "1" if self.conditionTbl.cellWidget(i,0) and self.conditionTbl.cellWidget(i,0).isChecked() else "0"
      condStr += str(self.conditionTbl.cellWidget(i,1).currentText())+","+str(self.conditionTbl.cellWidget(i,2).currentText())+","+str(self.conditionTbl.item(i,3).text())+","+checked+"|"

    axesStr = ""
    for i in xrange(self.axesTbl.rowCount()):
      checked = "1" if self.axesTbl.cellWidget(i,3) and self.axesTbl.cellWidget(i,3).isChecked() else "0"
      axesStr += str(self.axesTbl.cellWidget(i,0).currentText())+","+str(self.axesTbl.item(i,1).text())+","+str(self.axesTbl.item(i,2).text())+","+checked+"|"
    message( "\tAxes: '%s'" % axesStr)

    fitStr = ""
    if self.parametersTbl.rowCount() > 0:
      for i in xrange(self.parametersTbl.rowCount()):
        keepchecked = "1" if self.parametersTbl.cellWidget(i,2) and self.parametersTbl.cellWidget(i,2).isChecked() else "0"
        fixedchecked = "1" if self.parametersTbl.cellWidget(i,3) and self.parametersTbl.cellWidget(i,3).isChecked() else "0"
        fitStr += str(self.parametersTbl.item(i,0).text())+","+str(self.parametersTbl.item(i,1).text())+","+keepchecked+","+fixedchecked+"|"
    message( "\tFit: '%s'" % fitStr)
    fitplugin = self.fitTypeCombo.currentText()
    
    transformplugin = self.transformTypeCombo.currentText()
    transformStr = ""
    for i in xrange(self.transformConstantTbl.rowCount()):
      transformStr += str(self.transformConstantTbl.item(i,1).text())+"|"
    message( "\tTransforms: '%s'" % transformStr)
    
    temp = str(self.infoTempEdit.text())
    hold = str(self.infoHoldingEdit.text())
    trap = str(self.infoTrapEdit.text())
    ramp = str(self.infoRampingEdit.text())
    comp = str(self.infoCompressedEdit.text())
    cali = str(self.calibrationEdit.text())
    text = str(self.infoEdit.toPlainText())
    try:
      self.conditionCursor.execute("REPLACE INTO conditionTable (id, Date, Dataset, Conditions, Temperature, Holding, Trap, Ramping, Compressed, Calibration, Text, axes, fitplugin, fitparameters, transformplugin, transformparameters)" \
                        "VALUES(%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)" \
                        , (idstr, self.date, self.dataset, condStr, temp, hold, trap, ramp, comp, cali, text, axesStr, fitplugin, fitStr, transformplugin, transformStr))
    except mysql.Error,e:
      print "Something went wrong while I wanted to save date, too much information in one column, alter the table column accordingly"
      print e
      pass
    
    self.db.commit()
  #saveInfo(self,i=0)

  def loadInfo(self):
    if self.tabWidget.currentIndex() == 4:
      message( "you are just writing something, so no updating!")
      return
    
    self.conditionCursor.execute("SELECT Date, Dataset, Conditions, Temperature, Holding, Trap, Ramping, Compressed, Calibration, Text, axes " \
                       "FROM conditionTable WHERE Date=%s and Dataset=%s LIMIT 1", (self.date,self.dataset))
    dt = self.conditionCursor.fetchall()

    if len(dt) > 0:
      self.infoTempEdit.setText(dt[0][3])
      self.infoHoldingEdit.setText(dt[0][4])
      self.infoTrapEdit.setText(dt[0][5])
      self.infoRampingEdit.setText(dt[0][6])
      self.infoCompressedEdit.setText(dt[0][7])
      self.calibrationEdit.setText(dt[0][8])
      self.infoEdit.setPlainText(dt[0][9])
    else:
      self.infoTempEdit.setText("n/a")
      self.infoHoldingEdit.setText("n/a")
      self.infoTrapEdit.setText("n/a")
      self.infoRampingEdit.setText("n/a")
      self.infoCompressedEdit.setText("n/a")
      self.calibrationEdit.setText("n/a")
      self.infoEdit.setPlainText("n/a")
      
    if len(dt)>0 and not dt[0][2] == None:
      conditionStrs = str(dt[0][2]).split("|")[:-1]
      self.numConditions = len(conditionStrs)
    else:
      self.numConditions = 1
      
    if len(dt)>0 and not dt[0][10] == None:
      axesStrs = (str(dt[0][10]).split("|"))[:-1]
      self.numAxes = len(axesStrs)
    else:
      self.numAxes = 2
  #loadInfo(self)

  def updateConditions(self):
    # conditions
    self.conditionCursor.execute("SELECT Conditions " \
                       "FROM conditionTable WHERE Date=%s and Dataset=%s LIMIT 1", (self.date,self.dataset))
    dt = self.conditionCursor.fetchall()

    if len(dt)>0 and not dt[0][0] == None:
      conditionStrs = str(dt[0][0]).split("|")[:-1]
    else:
      conditionStrs = ["N_atoms,>,0"] # standard conditions

    if self.numConditions > 1:
      self.removeConditionButton.setEnabled(True)
    else:
      self.removeConditionButton.setEnabled(False)

    try:
      QtCore.QObject.disconnect(self.conditionTbl, QtCore.SIGNAL('cellChanged(int, int)'),self.loadData)

      # matically update output with change
      self.conditionTbl.setColumnCount(4)
      self.conditionTbl.setRowCount(self.numConditions)
      self.conditionTbl.horizontalHeader().setVisible(True)
      
      for row in xrange(self.conditionTbl.rowCount()):

        if row < len(conditionStrs):
          cCondition = conditionStrs[row].split(",") # saved conditions for this one
          if len(cCondition)==3:
            cCondition.append("1")
        else:
          cCondition = ["Measnumber","!=","0","1"]

        check=self.conditionTbl.cellWidget(row,0)
        combo=self.conditionTbl.cellWidget(row,1)
        ccombo=self.conditionTbl.cellWidget(row,2)
        
        # row is non-exist, so create everything and set the default values
        storedValue = ''
        if combo:
          storedValue = combo.currentText()
        else:
          check = QtGui.QCheckBox(self) 
          self.conditionTbl.setCellWidget(row,0,check);
          combo = QtGui.QComboBox(self,maxVisibleItems=40,editable=1) 
          self.conditionTbl.setCellWidget(row,1,combo);
          self.conditionTbl.setItem(row,3,QtGui.QTableWidgetItem("0" if row > 0 else "2000"))
          
          #create comparison combo
          ccombo = QtGui.QComboBox(self) 
          self.conditionTbl.setCellWidget(row,2,ccombo)
          self.conditionTbl.setRowHeight(row,20)
          
          for c in self.comparisons:
            ccombo.addItem(QtCore.QString(c))
            
          if row==0:
            ccombo.setCurrentIndex(3)

          QtCore.QObject.connect(ccombo, QtCore.SIGNAL("activated(int)"), self.loadData)
          QtCore.QObject.connect(combo, QtCore.SIGNAL("activated(int)"), self.loadData)
          QtCore.QObject.connect(check, QtCore.SIGNAL("clicked()"), self.loadData)

        check.setChecked(cCondition[3]=="1")
        combo=self.conditionTbl.cellWidget(row,1)
        combo.clear()

        for i,desc in enumerate(self.keys):
          combo.addItem(QtCore.QString(desc[0]))

          if cCondition[0] == desc[0]:
              combo.setCurrentIndex(i)
              self.restoreComboIndex(ccombo, cCondition[1])
              self.conditionTbl.setItem(row,3,QtGui.QTableWidgetItem(cCondition[2]))

    finally:
      QtCore.QObject.connect(self.conditionTbl, QtCore.SIGNAL('cellChanged(int, int)'),self.loadData)       
  #updateConditions(self)

  def beginData(self):
    self.fileWatch.removePath(self.pathname+"/../db/mysqldb.log");
    QtCore.QObject.disconnect(self.dateCombo, QtCore.SIGNAL('activated(const QString&)'),self.dateSelected)
  #beginData(self)

  def endData(self):
    self.fileWatch.addPath(self.pathname+"/../db/mysqldb.log");
    QtCore.QObject.connect(self.dateCombo, QtCore.SIGNAL('activated(const QString&)'),self.dateSelected)     
  #endData(self)

  def toggleConditions(self):
    if self.disableConditionsButton.isChecked():
      self.conditionTbl.setEnabled(False)
    else:
      self.conditionTbl.setEnabled(True)
    
    self.loadData()
  #toggleConditions(self)

  def resetAxisStyle(self):
    for l in [self.xaxisLabel,self.yaxisLabel,self.xaxisUnit,self.yaxisUnit]: l.setText("")
    self.loadData()
  #resetAxisStyle(self)

  def resetRange(self):
    for l in [self.xrangeMaxSpin,self.yrangeMaxSpin]: l.setValue(1)
    for l in [self.xrangeMinSpin,self.yrangeMinSpin]: l.setValue(0)
    self.updateRangeButton.setChecked(0)
    self.loadData()
  #resetRange(self)

  def copyPlotToClipboard(self):
    cb = QtGui.QApplication.clipboard()
    pic = QtGui.QPicture()
    pixmap = QtGui.QPixmap(self.mainPlot.width(),self.mainPlot.height())
    pixmap.fill()
    self.mainPlot.print_(pixmap)
    cb.setPixmap(pixmap)
  #copyPlotToClipboard(self)

  def copyDataToClipboard(self):
    cb = QtGui.QApplication.clipboard()
    axesCaptions = []
    for i in xrange(self.axesTbl.rowCount()):
      axesCaptions.append(str(self.axesTbl.cellWidget(i,0).currentText()))
      axesCaptions.append("\t")

    if self.averageDataButton.isChecked():
      for i in xrange(self.axesTbl.rowCount()):
        axesCaptions.append("d"+str(self.axesTbl.cellWidget(i,0).currentText()))
        axesCaptions.append("\t")
    axesCaptions.append("\n")
    axesCaptions.append("\n")
    
    rows = []
    if not self.averageDataButton.isChecked():
      for r in np.transpose(self.currentData):
        for c in r:
          rows.append("".join(str(c)))
          rows.append("\t")
        rows.append("\n")
    else:
      for r in (np.transpose(zip(self.currentData,self.currentErrData))):
        rows.append("\t".join(map(str,r[0])))
        rows.append("\t")
        rows.append("\t".join(map(str,r[1])))
        rows.append("\t")
        rows.append("\n")

    cb.setText("".join(axesCaptions)+"\n"+"".join(rows))
  #copyDataToClipboard(self)

  def loadSettings(self):
     if self.db == None:
       return
     # restore settings
     settings = QtCore.QSettings("LevT","sql_data_plot")
     # restore last status
     message ("Load settings")
     self.restoreComboIndex(self.dateCombo, settings.value("Date").toString())
     self.dateSelected(self.dateCombo.currentText())
 
     self.restoreListIndex(self.datasetList,settings.value("Dataset").toString())
     self.datasetSelected(self.datasetList.currentItem())
     
     self.fitDataButton.setChecked(settings.value("fitData").toBool())
     self.transformDataButton.setChecked(settings.value("transformData").toBool())
     self.averageDataButton.setChecked(settings.value("averageData").toBool())

     # restore settings concering axes selections
     axesList = settings.value("axesList").toList()
     axesScaleList = settings.value("axesScaleList").toList()
     axesOffsetList = settings.value("axesOffsetList").toList()
     axesFitList = settings.value("axesFitList").toList()
     
     #restore tabwidget
     self.tabWidget.setCurrentIndex(settings.value("tabWidthIndex").toInt()[0])

     #style settings
     self.xaxisLabel.setText(settings.value("xlabel").toString())
     self.yaxisLabel.setText(settings.value("ylabel").toString())
     self.xaxisUnit.setText(settings.value("xunit").toString())
     self.yaxisUnit.setText(settings.value("yunit").toString())
     self.plotStyleListLinePlot.setChecked(settings.value("listlineplot").toBool())
     self.plotStyleListPlot.setChecked(settings.value("listplot").toBool())
  #loadSettings(self)

  def closeEvent(self, event):
     self.authenticateDialog.close()
     if self.db == None:
       message ("Not saving anything, you are not connected to a database")
       return
     
     settings = QtCore.QSettings("LevT","sql_data_plot")
     settings.setValue("Date", self.dateCombo.currentText())
     settings.setValue("Dataset", self.datasetList.currentItem().text())
     settings.setValue("fitData", self.fitDataButton.isChecked())
     settings.setValue("transformData", self.transformDataButton.isChecked())
     settings.setValue("averageData", self.averageDataButton.isChecked())

     # store settings concering axes selections
     axesList = [self.axesTbl.cellWidget(i,0).currentText() for i in xrange(self.axesTbl.rowCount())]
     axesScaleList = [self.axesTbl.item(i,1).text() for i in xrange(self.axesTbl.rowCount())]
     axesOffsetList = [self.axesTbl.item(i,2).text() for i in xrange(self.axesTbl.rowCount())]
     axesFitList = [self.axesTbl.cellWidget(i+1,3).isChecked() for i in xrange(self.axesTbl.rowCount()-1)]
     settings.setValue("axesList", QtCore.QVariant(axesList))
     settings.setValue("axesScaleList", QtCore.QVariant(axesScaleList))
     settings.setValue("axesOffsetList", QtCore.QVariant(axesOffsetList))
     settings.setValue("axesFitList", QtCore.QVariant(axesFitList))

     # store transformation settings
     settings.setValue("transformType",self.transformTypeCombo.currentText())
     transformValueList = [self.transformConstantTbl.item(i,1).text() for i in xrange(self.transformConstantTbl.rowCount())] 
     settings.setValue("transformValueList", QtCore.QVariant(transformValueList))

     # store tabview settings
     settings.setValue("tabWidthIndex", QtCore.QVariant(self.tabWidget.currentIndex()))

     #restore fit settings
     settings.setValue("fitType",self.fitTypeCombo.currentText())

     #style settings
     settings.setValue("xlabel",self.xaxisLabel.text())
     settings.setValue("ylabel",self.yaxisLabel.text())
     settings.setValue("xunit",self.xaxisUnit.text())
     settings.setValue("yunit",self.yaxisUnit.text())
     settings.setValue("listlineplot",self.plotStyleListLinePlot.isChecked())
     settings.setValue("listplot",self.plotStyleListPlot.isChecked())
     settings.sync()
     message ("Closed app")
  #closeEvent(self, event)

  def restoreComboIndex(self, combo, text):
    idx = combo.findText(text, QtCore.Qt.MatchExactly)
    combo.setCurrentIndex(idx)
  #restoreComboIndex(self, combo, text)
    
  def restoreListIndex(self, qlist, text):
    idx = qlist.findItems(text, QtCore.Qt.MatchExactly)
    if idx:
      qlist.setCurrentItem(idx[0])
    else:
      qlist.setCurrentRow(0)
  #restoreListIndex(self, qlist, text)

  def changePickingMode(self, mode):
    message ("changed picking mode to: "+mode)
    self.pickingMode = mode
    if mode=="zoom":
      self.zoomer.setEnabled(True)
      self.picker.setEnabled(False)
      self.panner.setEnabled(False)
    elif mode=="kick" or mode=="identify":
      self.picker.setEnabled(True)
      self.zoomer.setEnabled(False)
      self.panner.setEnabled(False)
    elif mode=="pan":
      self.picker.setEnabled(False)
      self.zoomer.setEnabled(False)
      self.panner.setEnabled(True)
  #changePickingMode(self, mode)

  def showCoordinates(self, position):
    self.statusBar().showMessage('x = %+.6g, y = %.6g' \
            % (self.mainPlot.invTransform(Qwt.QwtPlot.xBottom, position.x()), \
               self.mainPlot.invTransform(Qwt.QwtPlot.yLeft, position.y())))
  #showCoordinates(self, position)

  def exportData(self):
    """ call the windows for exporting something """
    self.exportDialog = ExportDialogWindow(self)    
    self.exportDialog.exec_()
  #exportData(self)

  def showSliceDialog(self):
    picList = [ self.pictureTbl.item(i,0).text() for i in self.pictureTbl.rowCount() ]
    self.sliceDialog = SliceDialogWindow(self, picList)
  #showSliceDialog(self)

  def pickedPoint(self, point):
    if self.currentData.size == 0:
      return

    if self.transformDataButton.isChecked():
      self.sdpStatusBar.showMessage("You can't kick a point in 'Transform data' mode")
      return
    
    try:
      multiplicators = [float(self.axesTbl.item(i,1).text()) for i in xrange(self.axesTbl.rowCount())]
      offsets = [float(self.axesTbl.item(i,2).text()) for i in xrange(self.axesTbl.rowCount())]
    except ValueError:
      errorMessage("Wrong multiplicators, 'float' expected")
      multiplicators = np.ones(self.axesTbl.rowCount())
      offsets = np.ones(self.axesTbl.rowCount())
      
    if len(self.curves) > 0:
      try:
        px = point.x()
        py = point.y()

        dist = -1
        scalex = np.amax(self.currentData[0,:]) - np.amin(self.currentData[0,:])
        scaley = np.amax(self.currentData[1,:]) - np.amin(self.currentData[1,:])
        for j,y in enumerate(self.currentData[1]):
          x =self.currentData[0,j]
          y =self.currentData[1,j]
          nd = (((x-px)/scalex)**2) + ((((y*multiplicators[1] + offsets[1])-py)/scaley)**2)
          if nd < dist or dist == -1:
             ox = x
             oy = y
             dist = nd


        if self.pickingMode == "identify" and self.averageDataButton.isChecked():
            self.sdpStatusBar.showMessage("selected point (%s, %s) (avg)" % (str(ox), str(oy)))
            return
                    
        self.dbcur.execute(str("SELECT Cyclenumber FROM dataTable WHERE Date=%s AND Dataset=%s AND "\
           ""+self.axesTbl.cellWidget(1,0).currentText()+"="+str(oy)+ \
           " AND "+self.axesTbl.cellWidget(0,0).currentText()+"="+str(ox)),(self.date,self.dataset))
        dt = self.dbcur.fetchmany(2)
        self.db.commit()
        if len(dt) == 1:
          if self.pickingMode == "kick":
            message("selected point (%s, %s) has Cyclenumber %s" % (str(x), str(y), str(int(float(dt[0][0])))))
            self.addCondition()
            self.restoreComboIndex(self.conditionTbl.cellWidget(self.conditionTbl.rowCount()-1,1), "Cyclenumber")
            self.restoreComboIndex(self.conditionTbl.cellWidget(self.conditionTbl.rowCount()-1,2), "!=")
            self.conditionTbl.setItem(self.conditionTbl.rowCount()-1,3,QtGui.QTableWidgetItem(str(int(float(dt[0][0])))))
            # kick this point
          elif self.pickingMode == "identify":
            message("selected point (%s, %s) has Cyclenumber %s" % (str(x), str(y), str(int(float(dt[0][0])))))
        else:
          message ("more than 1 point has been found")
          self.sdpStatusBar.showMessage("point is unclear")
        
        self.statusBar().showMessage('(%f.6, %f.6) has Cyclenumber: %s' % (ox, oy, str(int(float(dt[0][0])))))
      except IndexError as (errno, strerror):
        errorMessage ("IndexError, couldn't pick this point({0}): {1}".format(errno, strerror))
  #pickedPoint(self, point)

  def databaseChanged(self, f):
    """a file in the database directory got changed, check if we have to add something"""
      
    message ("notices a change in the database folder in '%s'" % f)

    self.preventLoadingData = False
    
    try:
      self.datasetList.clear()
      self.dateCombo.clear()
      self.connectToDatabase()
	  
      if not self.date == '' and not self.dataset =='' and self.dateCombo.count() > 0:
	#restore to old selection if this is possible
        lastData = self.dateCombo.findText(self.date, QtCore.Qt.MatchExactly)
        message ("restoring selection to %s/%s" % (self.dataset, self.date))
        self.dateCombo.setCurrentIndex(lastData)
        self.dateSelected(self.date)
	    
        lastDataset = self.datasetList.findItems(self.dataset, QtCore.Qt.MatchExactly)
        self.datasetList.setCurrentItem(lastDataset[0])
        self.datasetSelected(self.datasetList.currentItem())
      else:
        print "not restoring anything, something totally wrong?!"
    except:
      print "Error in 'databaseChanged'"
  #databaseChanged(self, f)

  def connectToDatabase(self, createTemporaryDatabase=True):      
    message ("changed database")

    try:
      # connect to mysql database
      print "connecting to mysql"
      ssl_settings = {
        'key': self.pathname+"/certificate/client-key.pem", \
        'ca': self.pathname+'/certificate/ca-cert.pem', \
        'cert': self.pathname+'/certificate/client-cert.pem'
      }
      self.db = mysql.connect(str(self.authenticateDialog.host), str(self.authenticateDialog.user), str(self.authenticateDialog.pwd), 'localdb', ssl=ssl_settings);
      self.dbcur = self.db.cursor()
        
      self.dbcur.execute("SET AUTOCOMMIT=1")
      self.dbcur.execute("show full processlist")
      print self.dbcur.fetchall()
      self.db.commit()
      print "... connected"

      # check if we are using ssl
      self.dbcur.execute("SHOW STATUS LIKE 'Ssl_cipher'")
      self.conditionCursor = self.db.cursor()
      dt = self.dbcur.fetchall()
      if len(dt) == 0:
        message("You are not using SSL, ABORT!!")
        raise
      else:
        message("You are using SSL")

      self.dbcur.execute("SELECT DISTINCT Date FROM dataTable ORDER BY id DESC");
      self.db.commit()
      dt = self.dbcur.fetchall()
      dateA = range(len(dt))
      self.dateCombo.clear()
      for i,d in enumerate(dt):
        dateA[i] = d[0]
        try:
          self.dateCombo.addItem(QtCore.QString(dateA[i]))
        except TypeError:
          pass
        
    except mysql.Error,e:
      self.setEnabled(False)
      self.sdpStatusBar.showMessage("Couldn't connect to MySQL server")
    except sqlite.OperationalError,e:
      print "handled a sqlite exception:"
      print e      
  #connectToDatabase(self, createTemporaryDatabase=True)

  def fitPluginSelected(self, pluginId, noloading=False):
    """ fit type changed, the trefore create a new instance of fit plugin"""
    # can't go on without anything plotted     
    self.fitSelectedPlugin = self.fitPlugins[pluginId]()

    # fill the parameter list
    parameters = self.fitSelectedPlugin.getParameters()
    
    autoparameters = [1 for i in parameters]
    if self.currentData.size == 0:
      message("no data plotted yet, finding initial values needs some data")
    else:
      autoparameters = self.fitSelectedPlugin.getInitialParameters(self.currentData)
    
    try:
      # this speeds up things a lot as changing items in the parameterlist would always update everything
      self.parametersTbl.blockSignals(True)
      self.parametersTbl.setRowCount(len(parameters))
      self.parametersTbl.setColumnCount(4)
      self.parametersTbl.setHorizontalHeaderLabels(["name", "init", "keep", "fixed"])
      self.parametersTbl.verticalHeader().hide()
      for i,p in enumerate(parameters):
        self.parametersTbl.setItem(i,0, QtGui.QTableWidgetItem(QtCore.QString(str(p))))
        self.parametersTbl.setItem(i,1, QtGui.QTableWidgetItem(QtCore.QString(str(autoparameters[i]))))
        self.parametersTbl.setCellWidget(i,2,QtGui.QCheckBox(self))
        self.parametersTbl.setCellWidget(i,3,QtGui.QCheckBox(self))
        self.parametersTbl.resizeColumnToContents(i)
        self.parametersTbl.setRowHeight(i,20)

    finally:
      self.parametersTbl.blockSignals(False)
    
    #update data
    if not noloading:
      self.loadData()
  #fitPluginSelected(self, pluginId, noloading=False)

  def transformPluginSelected(self, pluginId, noloading=False):
    """ fit type changed, therefore create a new instance of fit plugin"""

    self.transformSelectedPlugin = self.transformPlugins[pluginId]()
    constants = self.transformSelectedPlugin.getConstants()
    axes = self.transformSelectedPlugin.requieredInputParameters()

    text = self.transformSelectedPlugin.getInfoStr()
    text += "<hr><b>required input parameters:</b><br>"
    if axes:
      for a in axes:
        text += "<i>"+a+"</i><br>\n"
    else:
      text += "none"
    self.transformInfo.setText(text)
    
    self.transformConstantTbl.setColumnCount(2)
    self.transformConstantTbl.setHorizontalHeaderLabels(["constant", "value"])
    
    try:
      QtCore.QObject.disconnect(self.transformConstantTbl, QtCore.SIGNAL('cellChanged(int, int)'),self.loadData)
      
      if constants == None:
        constants = []

      self.transformConstantTbl.setRowCount(len(constants))

      for i,p in enumerate(constants):
        self.transformConstantTbl.setItem(i,0, QtGui.QTableWidgetItem(QtCore.QString(str(p))))
        if not self.transformConstantTbl.item(i,1):
          self.transformConstantTbl.setItem(i,1, QtGui.QTableWidgetItem(QtCore.QString("1")))
        self.transformConstantTbl.setRowHeight(i,20)
    finally:
      QtCore.QObject.connect(self.transformConstantTbl, QtCore.SIGNAL('cellChanged(int, int)'),self.loadData)   
   
    #update data
    if not noloading:
      self.loadData()
  #transformPluginSelected(self, pluginId, noloading=False)

  def fillAutoParameters(self):
    try:
      self.parametersTbl.blockSignals(True)
      parameters = self.fitSelectedPlugin.getInitialParameters(self.currentData)
    
      self.parametersTbl.setRowCount(len(parameters))
    
      for i,p in enumerate(parameters):
        if self.parametersTbl.cellWidget(i,2) and not self.parametersTbl.cellWidget(i,2).isChecked():
          print "auto-changing parameter"
          self.parametersTbl.setItem(i,1, QtGui.QTableWidgetItem(QtCore.QString(str(p))))
      
      self.loadData()
    finally:
      self.parametersTbl.blockSignals(False)
  #fillAutoParameters(self)

  def dateSelected(self, date):
    if date=="":
      return

    # save (old) settings
    if not (self.date=="" and self.dataset==""):
      self.saveInfo()
    
    self.date = str(date)
    message ("selected date "+date)
    self.dbcur.execute ("SELECT DISTINCT Dataset FROM dataTable WHERE Date=%s", str(date));
    self.db.commit()
    dt=self.dbcur.fetchall()
    sets = range(len(dt))
    self.datasetList.clear()
    for i,d in enumerate(dt):
      sets[i] = d[0]
      self.datasetList.addItem(QtCore.QString(sets[i]))
  #dateSelected(self, date)

  def datasetSelected(self, dataset):
    self._datasetselectedstart = time.time()
    self.getAxesStr()
    
    if dataset=="" or dataset==None:
      return

    # save (old) settings
    if not (self.date=="" and self.dataset==""):
      self.saveInfo()

    # store new stuff
    self.date = str(self.dateCombo.currentText())
    self.dataset = str(dataset.text())
      
    message ("selected %s / %s" % (self.dataset, self.date))
    if debugTiming: print "SELECT * FROM dataTable WHERE Date=%s AND Dataset=%s LIMIT 1" % (self.date,self.dataset)
    self.dbcur.execute ("SELECT * FROM dataTable WHERE Date=%s AND Dataset=%s LIMIT 1", (self.date,self.dataset))
    self.db.commit()
    self.keys = self.setKeys(self.dbcur.description)

    #update the output

    self._datasetselected = time.time()
    if debugTiming: print "timing datasetSelected: %.3f s" % (self._datasetselected-self._datasetselectedstart)
    
    self.loadInfo()

    self._tloadinfo = time.time()
    if debugTiming: print "timing loadInfo: %.3f s" % (self._tloadinfo-self._datasetselected)

    self.updateConditions()

    self._tupdatecond = time.time()
    if debugTiming: print "timing updateConditions: %.3f s" % (self._tupdatecond-self._tloadinfo)
    
    self.updateAxesList()

    self._tupdateaxeslist = time.time()
    if debugTiming: print "timing updateAxesList: %.3f s" % (self._tupdateaxeslist-self._tupdatecond)
    
    self.updateTransformPlugin()

    self._tupdatetransform = time.time()
    if debugTiming: print "timing updateTransform: %.3f s" % (self._tupdatetransform-self._tupdateaxeslist)
    
    self.updateFitPlugin()

    self._tupdatefitplugin = time.time()
    if debugTiming: print "timing updateFitPlugin: %.3f s" % (self._tupdatefitplugin-self._tupdatecond)
    
    self.loadData()

    self._tloaddata = time.time()
    if debugTiming: print "timing loadData: %.3f s" % (self._tloaddata-self._tupdatefitplugin)

    self.queryexectime = (self._tloaddata - self._datasetselectedstart)*1000
  #datasetSelected(self, dataset)

  def getAxesStr(self,i=0):
    axesStr = ""
    for i in xrange(self.axesTbl.rowCount()):
      checked = "1" if self.axesTbl.cellWidget(i,3) and self.axesTbl.cellWidget(i,3).isChecked() else "0"
      axesStr += str(self.axesTbl.cellWidget(i,0).currentText())+","+str(self.axesTbl.item(i,1).text())+","+str(self.axesTbl.item(i,2).text())+","+checked+"|"
    message( "\tAxes: '%s'" % axesStr)
    self.oldaxesStrs = axesStr
  #getAxesStr(self,i=0)

  def setKeys(self, keys):
    # todo get rid of unwanted keys
    return keys
  #setKeys(self, keys)

  def addAxes(self):
    self.saveInfo()
    self.numAxes+=1
    self.removeAxesButton.setEnabled(True)
    self.updateAxesList()
    self.loadData()
  #addAxes(self)

  def oldAxes(self):
    self.saveInfo()
    self.useoldAxes = 1
    self.updateAxesList()
    self.loadData()
    self.useoldAxes = 0
  #oldAxes(self)

  def removeAxes(self):
    self.saveInfo()
    if self.numAxes > 2:
      self.numAxes-=1
    if self.numAxes == 2:
      self.removeAxesButton.setEnabled(False)
    self.updateAxesList()
    self.loadData()
  #removeAxes(self)

  def addCondition(self):
    self.saveInfo()
    self.numConditions+=1
    self.removeConditionButton.setEnabled(True)
    self.updateConditions()
    self.loadData()
  #addCondition(self)

  def removeCondition(self):
    self.saveInfo()
    if self.numConditions > 1:
      self.numConditions-=1
    if self.numConditions == 1:
      self.removeConditionButton.setEnabled(False)
    self.updateConditions() 
    self.loadData()
  #removeCondition(self)

  def toggledTransform(self, noload=False):
    axesList = [str(self.axesTbl.cellWidget(i,0).currentText()) for i in xrange(self.axesTbl.rowCount())]
    if self.transformDataButton.isChecked() and self.transformSelectedPlugin.validInputParameters(axesList):
      self.axesTbl.setEnabled(False)
    else:
      self.axesTbl.setEnabled(True)

    if not noload:
      self.loadData()
  #toggledTransform(self, noload=False)

  def updateTransformPlugin(self):
    self.conditionCursor.execute("SELECT transformplugin,transformparameters " \
                       "FROM conditionTable WHERE Date=%s and Dataset=%s LIMIT 1", (self.date,self.dataset))
    dt = self.conditionCursor.fetchall()
      
    if len(dt)>0 and not dt[0][0] == None:
      message( "Stored Transform Plugin for '%s': '%s'" % (self.dataset, dt[0][0]))
      self.restoreComboIndex(self.transformTypeCombo, str(dt[0][0]))
      self.transformPluginSelected(self.transformTypeCombo.currentIndex(), True)
          
      try:
        QtCore.QObject.disconnect(self.transformConstantTbl, QtCore.SIGNAL('cellChanged(int, int)'),self.loadData)  

        const = (dt[0][1].split("|"))[:-1]
        message( "Stored Transform Constants for '%s': '%s'" % (self.dataset, str(const)))
        for i in xrange(self.transformConstantTbl.rowCount()):
          self.transformConstantTbl.setItem(i,1, QtGui.QTableWidgetItem(const[i]))
      finally:
        QtCore.QObject.connect(self.transformConstantTbl, QtCore.SIGNAL('cellChanged(int, int)'),self.loadData)  
  #updateTransformPlugin(self)

  def updateFitPlugin(self):
    self.conditionCursor.execute("SELECT fitplugin, fitparameters " \
                       "FROM conditionTable WHERE Date=%s and Dataset=%s LIMIT 1", (self.date,self.dataset))
    dt = self.conditionCursor.fetchall()
    fitStrs = []
    if len(dt)>0 and not dt[0][0] == None and not dt[0][1] == None and not dt[0][0] == "None":
      message( "Stored Fit Plugin for '%s': '%s'" % (self.dataset, dt[0][0]))
      fitplugin = dt[0][0]
      fitparams = (str(dt[0][1]).split("|"))[:-1]
    else:
      fitplugin = "None"
      fitparams = []

    print fitplugin
    print fitparams
    print "number of params: ",len(fitparams)
    numParams = len(fitparams)

    self.restoreComboIndex(self.fitTypeCombo,fitplugin)
    self.fitPluginSelected(self.fitTypeCombo.currentIndex(), True)
      
    try:
      self.parametersTbl.blockSignals(True)
      self.parametersTbl.setColumnCount(4)
      self.parametersTbl.setRowCount(numParams)
      self.parametersTbl.setHorizontalHeaderLabels(["name", "init", "keep", "fixed"])
      self.parametersTbl.verticalHeader().hide()
      self.parametersTbl.horizontalHeader().setVisible(True)
      
      for row in xrange(self.parametersTbl.rowCount()):
        if row < numParams:
          cFit = fitparams[row].split(",") # saved fit params
          if len(cFit)==4:
            cFit.append("1")
        else:
          cFit = ["","0","0","0"]
          
        self.parametersTbl.setItem(row,0, QtGui.QTableWidgetItem(QtCore.QString(cFit[0])))
        self.parametersTbl.setItem(row,1, QtGui.QTableWidgetItem(QtCore.QString(cFit[1])))
        keepcheck = QtGui.QCheckBox(self) 
        self.parametersTbl.setCellWidget(row,2,keepcheck);
        keepcheck.setChecked(cFit[2]=="1")
        fixedcheck = QtGui.QCheckBox(self) 
        self.parametersTbl.setCellWidget(row,3,fixedcheck);
        fixedcheck.setChecked(cFit[3]=="1")
        self.parametersTbl.resizeColumnToContents(row)
        self.parametersTbl.setRowHeight(row,20)
        
    finally:
      self.parametersTbl.blockSignals(False)
  #updateFitPlugin(self)

  def updateAxesList(self):
    """update label in axes list and all the conditions list"""
    # conditions
    if self.date == "" or self.dataset=="":
      return

    self.conditionCursor.execute("SELECT axes " \
                       "FROM conditionTable WHERE Date=%s and Dataset=%s LIMIT 1", (self.date,self.dataset))
    dt = self.conditionCursor.fetchall()
    if self.useoldAxes == 1 and len(self.oldaxesStrs)!=0:
        axesStrs = (str(self.oldaxesStrs).split("|"))[:-1]
    else:
      if len(dt)>0 and not dt[0][0] == None:
        message ("Stored Axes for '%s': '%s'" % (self.dataset, dt[0][0]))
        axesStrs = (str(dt[0][0]).split("|"))[:-1]
      else:
        axesStrs = ["Cyclenumber,1,0,0","N_atoms,1,0,0"] # standard conditions

    self.axesTbl.setRowCount(self.numAxes)
    self.axesTbl.setColumnCount(4)
    self.axesTbl.setHorizontalHeaderLabels(["type", "scale", "offset", "fit"])
    self.axesTbl.horizontalHeader().setVisible(True)
    
    try:
      QtCore.QObject.disconnect(self.axesTbl, QtCore.SIGNAL('cellChanged(int, int)'),self.loadData)
      for row in xrange(self.numAxes):
        if row < len(axesStrs):
          cAxis = axesStrs[row].split(",")
          if len(cAxis)==3:
            cAxis.append("1")
        else:
          cAxis = ["N_atoms","1","0","1"] 

        combo=self.axesTbl.cellWidget(row,0)
        checkbox=self.axesTbl.cellWidget(row,3)
        storedValue = ''
        if combo:
          QtCore.QObject.disconnect(combo, QtCore.SIGNAL("activated(int)"), self.loadData)
          storedValue = combo.currentText()
        else:
          combo = QtGui.QComboBox(self,maxVisibleItems=40,editable=1)
          self.axesTbl.setCellWidget(row,0,combo)
       
          if row > 0:
            checkbox =  QtGui.QCheckBox()
            QtCore.QObject.connect(checkbox, QtCore.SIGNAL("clicked()"), self.loadData)
            self.axesTbl.setCellWidget(row,3, checkbox)

        # set axis properties (scale, offset, fit, combo)
        if checkbox:
          checkbox.setChecked(True if not cAxis[3] == "0" else False)
          
        self.axesTbl.setItem(row,1,QtGui.QTableWidgetItem(cAxis[1]))
        self.axesTbl.setItem(row,2,QtGui.QTableWidgetItem(cAxis[2]))
        self.axesTbl.setRowHeight(row,20)
        
        # keys might have changes, therefor refill this !""/$ again and select right key
        combo.clear()
        for i,desc in enumerate(self.keys):
          combo.addItem(QtCore.QString(desc[0]))
          if desc[0]==cAxis[0]:
            combo.setCurrentIndex(i)
        
        QtCore.QObject.connect(combo, QtCore.SIGNAL("activated(int)"), self.loadData)

    finally:
      QtCore.QObject.connect(self.axesTbl, QtCore.SIGNAL('cellChanged(int, int)'),self.loadData)   
  #updateAxesList(self)

  def loadData(self,r=0,c=0):
    """handle selected dataset: load data from database and generate array to plot"""
    
    #do nothing if there is not at least on x and y axis or if last update was smaller than 100 ms ago
    if self.axesTbl.rowCount() < 2 or self.preventLoadingData:
      message ("skipping")
      return
    
    message ("loadData")
    # auto reconnect to database if nessecary
    try:
      self.db.cursor()
    except (AttributeError, mysql.OperationalError):
      self.connectToDatabase()

    # gui adjustments, it's not clean to do this here, but it's fast so we don't care
    for i in xrange(self.axesTbl.rowCount()):
      self.axesTbl.resizeColumnToContents(i)

    for i in xrange(self.conditionTbl.rowCount()):
      self.conditionTbl.resizeColumnToContents(i)

    for i in xrange(self.parametersTbl.rowCount()-1):
      self.parametersTbl.resizeColumnToContents(i)
    
    date = self.dateCombo.currentText()
    dataset = self.datasetList.currentItem().text()
    conditionStr=""
    #get data to plot, first item in axesTbl corresponds to x-axes
    
    try:
      QtCore.QObject.disconnect(self.axesTbl, QtCore.SIGNAL('cellChanged(int, int)'),self.loadData)
      columns = []  
      for i in xrange(self.axesTbl.rowCount()):
        newColumn = self.axesTbl.cellWidget(i,0).currentText()     
        if newColumn=="":
          return
        columns.append(newColumn)

    except AttributeError:
      message("output is not ready yet")
      return
    finally:
      QtCore.QObject.connect(self.axesTbl, QtCore.SIGNAL('cellChanged(int, int)'),self.loadData)
      
     # join the column list. map to str, because the condition might be a QString
    columnStr = ",".join(map(str,columns))
        
    #get sql string for conditions, much nicer now. In fact it this is much better practice than string concatination in python
    conditions= [" "]
    if not self.disableConditionsButton.isChecked():
      try:
        for i in xrange(self.conditionTbl.rowCount()):
          if self.conditionTbl.cellWidget(i,0).isChecked():
            newCondition = self.conditionTbl.cellWidget(i,1).currentText()+self.conditionTbl.cellWidget(i,2).currentText()+self.conditionTbl.item(i,3).text()
          conditions.append(newCondition)

      except AttributeError:
        message("output is not ready yet")
        return
       
    for i in xrange(1, self.axesTbl.rowCount()):
      conditions.append(self.axesTbl.cellWidget(i,0).currentText()+"!='None' ")

    # join the condition list. map to str, because the condition might be a QString
    conditionStr = " AND ".join(map(str,conditions))
    
    # load data from database
    try:
      if debugTiming: print ("SELECT "+columnStr+" FROM dataTable WHERE Date=%s AND Dataset=%s "+conditionStr+" ORDER BY id") % (self.date,self.dataset)
      self.dbcur.execute (str("SELECT "+columnStr+" FROM dataTable WHERE Date=%s AND Dataset=%s "+conditionStr+" ORDER BY id"), (self.date,self.dataset))      
      dt = self.dbcur.fetchall()
      self.db.commit()
    except:
      # go on, even if there is an error
      self.sdpStatusBar.showMessage("Error in loading data")
      dt = []

    self.currentData = np.ones((self.axesTbl.rowCount(),len(dt)))
    # there's not much todo with no data at all
    if len(dt) == 0:
      message ("no datapoints to plot")
      self.sdpStatusBar.showMessage("no datapoints or an invalid axis (containing no datapoints) has been selected!")

      for c in self.curves:
          c.detach()

      self.mainPlot.replot()
      return;
      
    message ("plotting columns '%s' for '%s'/'%s' with '%s' datapoints and fit '%s'" % (columnStr, date, dataset, str(len(dt)), self.fitSelectedPlugin.getFitModelStr()))

    try:
      self.dbcur.execute ("SHOW TABLE STATUS")
      dtstatus = self.dbcur.fetchall()
      self.db.commit()
    except:
      # go on, even if there is an error
      self.sdpStatusBar.showMessage("Error in loading data")
      dtstatus = []

    tstatusstr = " - "
    if len(dtstatus) != 0:
      for row in dtstatus:
        tname = row[0]
        trows = row[4]/1000
        tsize = row[6]/1024/1024
        tstatusstr = tstatusstr + ("%s: %dMB " % (tname,tsize))

    querytimestr = " - query execution time: %dms" % (self.queryexectime)
    self.sdpStatusBar.showMessage(datetime.now().strftime("last update @ %b %d %H:%M:%S")+querytimestr+tstatusstr)
    
    try:
      #iterate through all axes and values
      for j in xrange(self.axesTbl.rowCount()):
        #self.currentData[j] = np.ones((len(dt))
        for i,d in enumerate(dt):
          self.currentData[j,i] = float(d[j])
    except ValueError:
      message("some data that is not actual numerical is selected")
      return
    except TypeError:
      message("some data that is not actual numerical is selected")
      return

    self.currentLast = self.currentData[:,-1]
    
    #sort data
    self.currentData = self.currentData[:,self.currentData[0,:].argsort()]

    #get the new indices of the last data
    lastIndices = [np.where(self.currentData[i,:] == self.currentLast[i])[0][0] for i in xrange(self.currentData.shape[0])]

    # transform if wanted
    if self.transformDataButton.isChecked():
      self.transformData()

      #sort after transform
      self.currentData = self.currentData[:,self.currentData[0,:].argsort()]

    self.currentLast = [ self.currentData[i, lastIndices[i]] for i in xrange(self.currentData.shape[0])]
    
    #average data
    if self.averageDataButton.isChecked():
      self.averageData()
    else:
      self.currentErrData = np.array([])
      
    #fit all the data
    if self.fitDataButton.isChecked():
      self.fitData()
    else:
      currentFitData = np.array([])

    self.updateOutput()
    self.saveInfo() # save current setup if loadData succeed.
  #loadData(self,r=0,c=0)

  def fitData(self):
    """fill the current fitting data array up"""
    # deal with it if
    try:
      param=[]
      for i in xrange(self.parametersTbl.rowCount()):
        paramv=float(self.parametersTbl.item(i,1).text())
        paramfix=True if self.parametersTbl.cellWidget(i,3) and self.parametersTbl.cellWidget(i,3).isChecked() else False
        param.append([paramv,paramfix])
      fitSelection = [self.axesTbl.cellWidget(i,3).isChecked() for i in xrange(1,self.axesTbl.rowCount()) ]
      self.currentFitData = self.fitSelectedPlugin.fit(self.currentData, self.currentErrData, param, xmin=self.fitFromSpin.value(), xmax=self.fitToSpin.value(), fitAxes=fitSelection)
    except (ValueError, TypeError):
      self.textEdit.setText("fitting error")
      print "Fit is not converging!"
      self.sdpStatusBar.showMessage("the fit is not converging, try 'Reset to recommanded initial parameters' or change them manually!")
      self.currentFitData = np.array([]) 
    finally:
      pass
      
    # put out all the fit parameters
    try:
      # this speeds up things a lot as changing items in the parameterlist would always update everything
      self.parametersTbl.blockSignals(True)
      parameters = self.fitSelectedPlugin.getParameters()
      
      # TODO von anderen fits die parameter!
      plainText = ""
      plugin = self.fitSelectedPlugin
      info = self.fitSelectedPlugin.getInfoStr()
      for ai in xrange(self.axesTbl.rowCount()-1):
        plainText = "%s<p style=\"font-size:11pt;font-weight:bold; margin:0px;\">%s:</p> " \
                    "<hr>" % (plainText,self.axesTbl.cellWidget(ai+1,0).currentText())
        if self.fitSelectedPlugin.isConverged():
          plainText = "%s<p style=\"margin-top:0px; margin-bottom:5px;margin-left:10px\">" % plainText
          for i in xrange(len(parameters)):
            plainText = "%s<b>%s</b>=\t<span style=\"font-weight: bold;font-size:10pt;color:#00aa00;\">%s +/- %s</span><br>" % (plainText,self.parametersTbl.item(i,0).text(),round_to_n(plugin.rp[ai][i],5),round_to_n(plugin.rerr[ai][i],5))

        if info:
          plainText = "%s\t info: %s</p>" % (plainText,info[ai])
        
      self.textEdit.setText(plainText)
    except (ValueError, TypeError):
      self.currentFitData = np.array([]) 
      self.textEdit.setText("Fit is not converging!")      
    finally:
      self.parametersTbl.blockSignals(False)
  #fitData(self)
   
  def averageData(self):
    """average over datapoints with same x-coord and generate corresponding error values"""
    def mean(array):
      return np.sum(array)/array.size
      
    def stdSqrtN(array):
      return np.std(array)/sqrt(array.size)

    def std(array):
      return np.std(array)
      
    data=self.currentData.T

    lenx=len(set(self.currentData[0,:]))
    
    self.currentData=np.ones((lenx, self.axesTbl.rowCount()))
    self.currentErrData=np.ones((lenx, self.axesTbl.rowCount()))
    dealedwith=np.array([ ])
    # find all duplicated items
    d=0
    for i in data:
      dealedwith = np.append(dealedwith, i[0])
      # found an already existing x value
      if dealedwith[dealedwith == i[0]].size == 1:
        self.currentData[d,:] = map(mean, data[data[:,0] == i[0]].T)

        if self.avgStdSqrtN.isChecked():
          self.currentErrData[d,:] = map(stdSqrtN, data[data[:,0] == i[0]].T)
        else:
          self.currentErrData[d,:] = map(std, data[data[:,0] == i[0]].T)
                  
        d+=1
        
    self.currentData = (self.currentData.T)
    self.currentErrData = (self.currentErrData.T)
  #averageData(self)

  def transformData(self):
    axesList = [str(self.axesTbl.cellWidget(i,0).currentText()) for i in xrange(self.axesTbl.rowCount())]
    if self.transformSelectedPlugin.validInputParameters(axesList):
      constantList = [float(self.transformConstantTbl.item(i,1).text()) for i in xrange(self.transformConstantTbl.rowCount())]

      try:
        self.currentData = self.transformSelectedPlugin.transform(self.currentData,axesList,constantList)
      except KeyError:
        self.sdpStatusBar.showMessage("You don't have the right input parameters (axes) for this transformation")
        self.currentData = np.array([])
    else:
      print "couldn't transform, wrong input parameters"
      self.sdpStatusBar.showMessage("couldn't transform, wrong input parameters")  
  #transformData(self)

  def showCurve(self,index, xdata, ydata, yerrdata=None, hints=False, colorIdx=0,title=None):
    # only create a new curve non is existent for current index
    if index >= len(self.curves):
      curve = ErrorBarPlotCurve()
      curve.setRenderHint(Qwt.QwtPlotItem.RenderAntialiased)
      
      self.curves.append(curve)
    else:
      curve = self.curves[index]
    
    #different styles for fits and curves
    penStyle = QtCore.Qt.SolidLine if self.plotStyleListLinePlot.isChecked() else QtCore.Qt.NoPen
    if hints =="fit":
      pen = QtGui.QPen(QtCore.Qt.SolidLine)
      pen.setColor(QtCore.Qt.GlobalColor(colorIdx+7))
      curveSymbol = Qwt.QwtSymbol()
      pen.setWidth(2)

    elif hints =="dot":
      pen = QtGui.QPen(penStyle)
      pen.setColor(QtCore.Qt.GlobalColor(colorIdx+7))

      curvePen = QtGui.QPen(QtCore.Qt.black),
      curveSymbol = Qwt.QwtSymbol(Qwt.QwtSymbol.XCross,QtGui.QBrush(QtCore.Qt.black),\
                                    QtGui.QPen(QtCore.Qt.black, 1),\
                                    QtCore.QSize(16, 16))
      curve.setItemAttribute(Qwt.QwtPlotItem.Legend, False);
    else:
      pen = QtGui.QPen(penStyle)
      pen.setColor(QtCore.Qt.GlobalColor(colorIdx+7))

      curvePen = QtGui.QPen(QtCore.Qt.black),
      curveSymbol = Qwt.QwtSymbol(Qwt.QwtSymbol.Ellipse,QtGui.QBrush(QtCore.Qt.GlobalColor(colorIdx+7)),\
                                    QtGui.QPen(QtCore.Qt.black, 1),\
                                    QtCore.QSize(8, 8))

    if not hints == "dot":
      if not title:
        curve.setTitle(self.axesTbl.cellWidget(colorIdx+1,0).currentText())
      else:
        curve.setTitle(title)

    if not yerrdata == None:
      curve.setErrorPen(QtCore.Qt.black)
      curve.setErrorCap(5)
    else:
      curve.setErrorPen(QtGui.QPen())
      curve.setErrorCap(0)
      
    curve.setStyle(Qwt.QwtPlotCurve.Lines)  
    curve.setPen(pen)  
    curve.setSymbol(curveSymbol)
    curve.setData(xdata, ydata,None,yerrdata)  
    curve.attach(self.mainPlot)
  #showCurve(self,index, xdata, ydata, yerrdata=None, hints=False, colorIdx=0,title=None)

  def updateOutput(self):
    """Updates all the output stuff according to settings""" 

    try:
      if not self.transformDataButton.isChecked():
        multiplicators = [float(self.axesTbl.item(i,1).text()) for i in xrange(self.axesTbl.rowCount())]
        offsets = [float(self.axesTbl.item(i,2).text()) for i in xrange(self.axesTbl.rowCount())]
      else:
        multiplicators = [1 for i in xrange(self.currentData.shape[0])]
        offsets = [0 for i in xrange(self.currentData.shape[0])]        
    except ValueError:
      errorMessage("Wrong multiplicators, 'float' expected")
      multiplicators = np.ones(self.axesTbl.rowCount())
      offsets = np.ones(self.axesTbl.rowCount())
      
    # plotting
    curveIndex = 0;
    for j in xrange(self.currentData.shape[0]-1):
      # is fitting data available?
      if self.currentFitData.size > 0 and self.axesTbl.cellWidget(j+1, 3).isChecked() and self.fitDataButton.isChecked():
        self.showCurve(curveIndex,self.currentFitData[0]*multiplicators[0] + offsets[0], self.currentFitData[j+1]*multiplicators[j+1] + offsets[j+1], hints="fit", colorIdx=j)
        curveIndex+=1

      errData = self.currentErrData[j+1]*multiplicators[j+1] if self.currentErrData.size > 0 else None
      self.showCurve(curveIndex,self.currentData[0]*multiplicators[0] + offsets[0],self.currentData[j+1]*multiplicators[j+1] + offsets[j+1],errData, colorIdx=j, title="" if not self.transformDataButton.isChecked() else self.transformSelectedPlugin.getTransformModelStr())
      self.showCurve(curveIndex+1,np.array([self.currentLast[0]])*multiplicators[0] + offsets[0],np.array([self.currentLast[j+1]])*multiplicators[j+1] + offsets[j+1],None,hints="dot", colorIdx=j)

      curveIndex+=2
    
    xtext = self.xaxisLabel.text()+"/"+self.xaxisUnit.text()
    ytext = self.yaxisLabel.text()+"/"+self.yaxisUnit.text()
    self.mainPlot.setAxisTitle(Qwt.QwtPlot.xBottom, self.axesTbl.cellWidget(0,0).currentText() if xtext=="/" else xtext)
    self.mainPlot.setAxisTitle(Qwt.QwtPlot.yLeft, "" if ytext=="/" else ytext)

    # disable all unnecessary curves
    for i in xrange(curveIndex, len(self.curves)):
      self.curves[i].detach()
      
    if self.pickingMode == "zoom":
      self.clearZoomStack()

    if self.updateRangeButton.isChecked():
      self.mainPlot.setAxisScale(Qwt.QwtPlot.yLeft, self.yrangeMinSpin.value(), self.yrangeMaxSpin.value())
      self.mainPlot.setAxisScale(Qwt.QwtPlot.xBottom, self.xrangeMinSpin.value(), self.xrangeMaxSpin.value())
    else:
      self.clearZoomStack
      
    self.mainPlot.replot()
  #updateOutput(self)

  def clearZoomStack(self):
    self.mainPlot.setAxisAutoScale(Qwt.QwtPlot.xBottom)
    self.mainPlot.setAxisAutoScale(Qwt.QwtPlot.yLeft)
    self.zoomer.setZoomBase()
  #clearZoomStack(self)

# create the GUI application
app = QtGui.QApplication(sys.argv)
# instantiate the main window
dmw = SqlDataPlotMainWindow()
# show it
dmw.show()
# start the Qt main loop execution, exiting from this script
# with the same return code of Qt application
sys.exit(app.exec_())
